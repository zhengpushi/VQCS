(*
  purpose   : Quantity.
  author    : Zhengpu Shi
  date      : 2022.04
  
  remark    :
  1. differences between arithmetic and algebra
  (1). arithmetic means add,sub,mul,div of numbers, prefer calculate directly.
  (2). algebra use numbers and variables sametime, and mainly use laws to 
    deal with the problem, prefer transform, not calculate.
  (3). algebra include power, algorithm and complex numbers too.
  
  2. u1 +/- u2, only if dims(u1) == dims(u2)

*)

(* From MyStdLibExt Require Export RExt. *)

Require Export RExt.
Require Export Unit Nunit SI Uconv.


(** * Quantity: data type for support algebric of [Unit]. *)

(** we mainly use R, not Q. *)
Open Scope R.

(** we mainly use semantics. *)
Open Scope NU_scope.

Declare Scope QU_scope.
Delimit Scope QU_scope with QU.
Open Scope QU_scope.


(** ** Definition of Quantity *)

(** A quantity is an option type that contains a pair of [R] and [Nunit], and 
 QUinvalid means an error state generated by invalid operation. *)
Inductive Quantity : Set :=
  | QUmake : R -> Nunit -> Quantity (* Notice, (R*Nunit) is a bit different *)
  | QUinvalid.

(* Bind Scope QU_scope with Quantity. *)

Notation "! q" := (not (q = QUinvalid)) (at level 0) : QU_scope.
Notation "!!" := (QUinvalid) (at level 0) : QU_scope.

(** Generate a Quantity from a [R] value and a [Unit] value. *)
Definition genQU (val : R) (u : Unit) := QUmake val (u2n u).

(** Convert real number to Quantity with Unit 1. *)
Definition real2QU (val : R) := genQU val #1.
Coercion real2QU : R >-> Quantity.


(** Convert [Unit] to Quantity with value 1. *)
Definition unit2QU (u : Unit) := genQU 1 u.
(* Note that, this coercion shouldno't open, it will disturb the real2QU.
We need to distinguish value and coefficient. *)
(* Coercion unit2QU : Unit >-> Quantity. *)

Notation "$1 u" := (unit2QU u) (at level 10) : QU_scope.

(* 
(** QUmake is injective. *)
Lemma QUmake_inj u1 u2 : QUmake u1 = QUmake u2 <-> u1 = u2.
Proof.
  split; intro H; inversion H; auto.
Qed. *)



(** ** Get components of a quantity *)
Definition QUcomps_opt (q : Quantity) : option (R * Q * Dims) :=
  match q with
  | QUmake v (mkNunit c d) => Some (v,c,d)
  | _ => None
  end.

Definition QUcomps (q : Quantity) (H : !q) : (R * Q * Dims).
Proof.
  destruct q as [v (c,d)|]. exact (v,c,d). easy.
Defined.



(** ** Get numerical value of a quantity *)
Definition QUvalue_opt (q : Quantity) : option R :=
  match q with
  | QUmake v _ => Some v
  | _ => None
  end.

Definition QUvalue_old (q : Quantity) (H : !q) : R.
Proof.
  destruct q as [v u|]. exact v. easy.
Defined.

Parameter QUvalueERR : R.
Definition QUvalue (q : Quantity) : R :=
  match q with
  | QUmake v (mkNunit c d) => v
  | _ => QUvalueERR
  end.
  



(** ** Get coefficient of the Nunit of a quantity *)
Definition QUcoef_opt (q : Quantity) : option Q :=
  match q with
  | QUmake v (mkNunit c d) => Some c
  | _ => None
  end.

Definition QUcoef_old (q : Quantity) (H : !q) : Q.
Proof.
  destruct q as [v (c,d)|]. exact c. easy.
Defined.

Parameter QUcoefERR : Q.
Definition QUcoef (q : Quantity) : Q :=
  match q with
  | QUmake v (mkNunit c d) => c
  | _ => QUcoefERR
  end.



(** ** Get dimensions of the Nunit of aquantity *)
Definition QUdim_opt (q : Quantity) : option Dims :=
  match q with
  | QUmake v (mkNunit c d) => Some d
  | _ => None
  end.

Definition QUdim_old (q : Quantity) (H : !q) : Dims.
Proof.
  destruct q as [v (c,d)|]. exact d. easy.
Defined.

Parameter QUdimERR : Dims.
Definition QUdim (q : Quantity) : Dims :=
  match q with
  | QUmake v (mkNunit c d) => d
  | _ => QUdimERR
  end.



(** ** Get [Unit] of a quantity *)

(** This version need a proof that the Q is valid. *)
Definition QUunit_old (q : Quantity) (H : !q) : Unit.
Proof.
  destruct q as [v n|]. exact (n2u n). easy.
Defined.

(** This version give an abstract UnitErr if Q is invalid, useful for debug *)
Parameter UnitErr : Unit.
Definition QUunit (q : Quantity) : Unit :=
  match q with
  | QUmake v n => n2u n
  | _ => UnitErr
  end.
  
(* Compute QUunit (genQU 3 'N). *)


(* (** QUunit is equal to a unit created by n2u with QUcoef and QUdim. *)
Lemma QUunit_eq_QUcoef_QUdim (q : Quantity) (H : !q) : 
  QUunit q H == n2u (QUcoef q H, QUdim q H).
Proof.
  destruct q; try easy. unfold QUcoef, QUdim, QUunit.
  destruct (u2n u) eqn:E1. unfold Ueq. rewrite u2n_n2u. auto.
Qe *)



(** ** Boolean comparison of two quantities *)

Definition QUcmpb (q1 q2 : Quantity) (Rcmpb : R -> R -> bool) : bool :=
  match q1,q2 with
  | QUmake v1 n1, QUmake v2 n2 => (Rcmpb v1 v2) && (n1 =? n2)
  | !!, !! => true  (* take care! *)
  | _, _ => false
  end.

(** Equal,Less Than, Less Equal of two quantities *)
Definition QUeqb (q1 q2 : Quantity) : bool := QUcmpb q1 q2 Reqb.
Definition QUltb (q1 q2 : Quantity) : bool := QUcmpb q1 q2 Rltb.
Definition QUleb (q1 q2 : Quantity) : bool := QUcmpb q1 q2 Rleb.

Infix "=?"  := QUeqb : QU_scope.
Infix "<?"  := QUltb : QU_scope.
Infix "<=?" := QUleb : QU_scope.

(** Examples *)
(* Compute (genQU 5 'min) =? (genQU (1+2*2) ('min *'N *'m / ('N * 'm))%U).
Compute (genQU 3 'N) <? (genQU 5 'N).
Compute (genQU 3 ('N*'m)%U) <? (genQU 5 ('mÂ²*'N*/'m)%U).
Compute (genQU 3 'A) <? (genQU 5 'N). (* the result is false definitely! *)
 *)

(** [QUeqb] is true, it reflexive. *)
Lemma QUeqb_true_refl q : q =? q = true.
Proof.
  unfold QUeqb,QUcmpb.
  destruct q as [v n|]; auto.
  rewrite Reqb_true_refl, Neqb_true_refl; auto.
Qed.

(** [QUeqb] is commutative *)
Lemma QUeqb_comm q1 q2 : (q1 =? q2) = (q2 =? q1).
Proof.
  unfold QUeqb,QUcmpb.
  destruct q1 as [v1 n1|],q2 as [v2 n2|]; auto.
  rewrite Reqb_comm, Neqb_comm; auto.
Qed.

(** [QUeqb] left with [!!] is true, iff the quantity is !! too. *)
Lemma QUeqb_left_qinvalid_true_iff : forall q, 
  ((!! =? q) = true) <-> q = QUinvalid.
Proof.
  intros. destruct q; simpl in *; auto; easy.
Qed.

(** [QUeqb] right with [!!] is true, iff the quantity is !! too. *)
Lemma QUeqb_right_qinvalid_true_iff : forall q, 
  ((q =? !!) = true) <-> q = QUinvalid.
Proof.
  intros. split; intro H.
  - rewrite QUeqb_comm in H. apply QUeqb_left_qinvalid_true_iff in H; auto.
  - subst. auto.
Qed.

(** [QUeqb] is true, it is transitive *)
Lemma QUeqb_true_trans q1 q2 q3 : (q1 =? q2 = true) -> (q2 =? q3 = true) ->
  (q1 =? q3 = true).
Proof.
  unfold QUeqb,QUcmpb.
  destruct q1 as [v1 n1|],q2 as [v2 n2|],q3 as [v3 n3|]; try easy.
  repeat rewrite andb_true_iff. intros H1 H2; destruct H1,H2.
  split.
  apply Reqb_trans with v2; auto.
  apply Neqb_true_trans with n2; auto.
Qed.

(* (** [QUeqb] is true, iff coefficient and dimensions all equal. *)
Lemma QUeqb_true_iff_QUeq_coef_dims_old q1 q2 (H1 : !q1) (H2 : !q2) : 
  (q1 =? q2 = true) <->
  (QUvalue q1 = QUvalue q2) /\ 
  (QUcoef q1 == QUcoef q2)%Q /\ (QUdim q1 = QUdim q2).
Proof.
  unfold QUcoef_opt, QUdim_opt, QUeqb,QUcmpb.
  destruct q1 eqn:E1, q2 eqn:E2; try easy.
  split; intros.
  - apply andb_true_iff in H. rewrite Reqb_true_iff,Neqb_true_iff in H.
    destruct H. destruct n,n0. inversion H0. simpl in *. auto.
  - destruct H,H0. unfold QUvalue, QUcoef, QUdim in *. destruct n,n0.
    apply andb_true_iff. split.
    + subst. apply Reqb_true_refl.
    + apply Neqb_true_iff. rewrite H0,H3. easy.
Qed. *)

(** [QUeqb] is true, iff coefficient and dimensions all equal. *)
Lemma QUeqb_true_iff_QUeq_coef_dims q1 q2 (H1 : !q1) (H2 : !q2) : 
  (q1 =? q2 = true) <->
    match QUvalue_opt q1,QUvalue_opt q2,QUcoef_opt q1,QUcoef_opt q2,
      QUdim_opt q1,QUdim_opt q2 with
    | Some v1, Some v2, Some c1, Some c2, Some d1, Some d2 =>
      v1 = v2 /\ (c1 == c2)%Q /\ d1 = d2
    | _, _, _, _, _, _ => False
    end.
Proof.
  unfold QUcoef_opt, QUdim_opt, QUeqb,QUcmpb.
  destruct q1 eqn:E1, q2 eqn:E2; try easy.
  rewrite andb_true_iff.
  rewrite Reqb_true_iff, Neqb_true_iff_Neq. simpl.
  destruct n,n0. split; intros [H3 H4].
  - inversion H4. simpl in *. easy.
  - destruct H4. try easy.
Qed.




(** ** Propositional comparison of two quantities *)

Definition QUeq (q1 q2 : Quantity) : Prop := q1 =? q2 = true.
Definition QUlt (q1 q2 : Quantity) : Prop := q1 <? q2 = true.
Definition QUle (q1 q2 : Quantity) : Prop := q1 <=? q2 = true.

Infix "==" := QUeq : QU_scope.
(* Infix "<>" := (not QUeq) : QU_scope. *) (* it is always wrong, careful *)
Infix "<" := QUlt : QU_scope.
Infix "<=" := QUle : QU_scope.

(** QUeq is an equivalence relation. *)

Lemma QUeq_refl q : q == q.
Proof.
  unfold QUeq. apply QUeqb_true_refl.
Qed.

Lemma QUeq_comm q1 q2 : q1 == q2 -> q2 == q1.
Proof.
  unfold QUeq. rewrite QUeqb_comm. auto.
Qed.

Lemma QUeq_trans q1 q2 q3 : q1 == q2 -> q2 == q3 -> q1 == q3.
Proof.
  unfold QUeq. apply (QUeqb_true_trans q1 q2 q3); auto.
Qed.

Lemma QUeq_equiv : equivalence Quantity QUeq.
Proof.
  intros. refine (Build_equivalence _ _ _ _ _); unfold QUeq.
  - intros x. apply QUeq_refl.
  - intros x1 x2 x3. apply QUeqb_true_trans.
  - intros x1 x2. rewrite QUeqb_comm. auto.
Qed.

(** Example, before registered relation, we can't rewrite. *)
Goal forall (q1 q2 q3 : Quantity), q1 == q2 -> q3 == q2 -> q1 == q3.
intros. 
(* Fail rewrite H.  *)
Abort.

(** Register that [QUeq] is equivalence relation. *)
Add Parametric Relation : Quantity QUeq
  reflexivity proved by (equiv_refl _ _ QUeq_equiv)
  symmetry proved by (equiv_sym _ _ QUeq_equiv)
  transitivity proved by (equiv_trans _ _ QUeq_equiv)
  as QUeq_rel.

(** Example, after registered relation, we can rewrite. *)
Goal forall (q1 q2 q3 : Quantity), q1 == q2 -> q3 == q2 -> q1 == q3.
intros. rewrite H. symmetry. auto. Qed.

(** [QUeq] imply [QUunit] of the quantities are equal. *)
Lemma QUeq_imply_QUunit_eq (q1 q2 : Quantity) (H1 : !q1) (H2 : !q2) :
  q1 == q2 -> (QUunit q1 == QUunit q2)%U.
Proof.
  destruct q1,q2; simpl; try easy.
  unfold QUeq,QUeqb,QUcmpb.
  rewrite andb_true_iff. rewrite Neqb_true_iff_Neq.
  intros [? H3]. rewrite H3. easy.
Qed.

(** [QUeq] iff [Ueq] when the quantity are valid. *)
Lemma QUeqb_true_iff_QUeq q1 q2 : q1 =? q2 = true <-> q1 == q2.
Proof.
  unfold QUeq,QUeqb. easy.
Qed.

(** [QUeq] of [QUmake] is bijective. *)
Lemma QUeq_QUmake_bij (c1 c2 : R) (n1 n2 : Nunit) : 
  (c1 = c2 /\ (n1 == n2)%NU) <-> QUmake c1 n1 == QUmake c2 n2.
Proof.
  unfold QUeq,QUeqb,QUcmpb in *.
  rewrite andb_true_iff,?Reqb_true_iff,?Neqb_true_iff_Neq. easy.
Qed.

(** Register that [QUmake] is compatible for [QUeq]. *)
Add Parametric Morphism : QUmake
  with signature eq ==> Neq ==> QUeq as QUmake_NUeq_QUeq_mor.
Proof.
  intros. apply QUeq_QUmake_bij. auto.
Qed.

(** Register that [QUeqb] is compatible for [QUeq]. *)
Add Parametric Morphism : QUeqb
  with signature QUeq ==> QUeq ==> eq as QUeqb_QUeq_QUeq_mor.
Proof.
  intros q1 q2 H1 q3 q4 H2.
  unfold QUeq,QUeqb,QUcmpb,Neqb in *.
  destruct q1 as [v1 (c1,d1)|], q2 as [v2 (c2,d2)|], q3 as [v3 (c3,d3)|], 
    q4 as [v4 (c4,d4)|]; try easy. simpl in *.
  rewrite ?andb_true_iff in *.
  destruct H1 as [H1a [H1b H1c]].
  destruct H2 as [H2a [H2b H2c]].
  rewrite Reqb_true_iff,Qeq_bool_iff,Deqb_true_iff_Deq in *.
  rewrite H1a,H1b,H1c,H2a,H2b,H2c.
  destruct (Qeq_bool c2 c4),(Deqb d2 d4); auto; simpl.
Qed.

(** Register that [QUvalue] is compatible for [QUeq]. *)
Add Parametric Morphism : QUvalue_opt
  with signature QUeq ==> eq as QUvalue_QUeq_mor.
Proof.
  intros q1 q2. destruct q1,q2; try easy. intros.
  apply QUeq_QUmake_bij in H. inversion H. rewrite H0.
  simpl. destruct n,n0. auto.
Qed.

(** [QUeq], iff coefficient and dimensions all equal. *)
Lemma QUeq_iff_coef_dims q1 q2 (H1 : !q1) (H2 : !q2) : 
  (q1 == q2) <->
    match QUvalue_opt q1,QUvalue_opt q2,QUcoef_opt q1,QUcoef_opt q2,
      QUdim_opt q1,QUdim_opt q2 with
    | Some v1, Some v2, Some c1, Some c2, Some d1, Some d2 =>
      v1 = v2 /\ (c1 == c2)%Q /\ d1 = d2
    | _, _, _, _, _, _ => False
    end.
Proof.
  split; intros; apply QUeqb_true_iff_QUeq_coef_dims; auto.
Qed.



(** ** Convert the unit of a Quantity *)

(** Check if two quantities have same unit.  *)
Definition QUsameunitb (q1 q2 : Quantity) : bool :=
  match q1, q2 with
  | QUmake _ n1, QUmake _ n2 => (n1 =? n2)%NU
  | _, _ => false
  end.

(** Propersional version. *)
Definition QUsameunit q1 q2 := QUsameunitb q1 q2 = true.

(** Convert a given quantity *q* with reference unit *ref*. If q is !! then 
return !!, else if q has convertible unit with ref, then generate a new 
quantity. *)
(** (r,c,d) ---(c',d)---> (r*c/c',c',d) *)
Definition QUconv (q : Quantity) (ref : Unit) : Quantity :=
  match q with
  | QUmake v n => match Uconv (n2u n) ref with
    | Some (k, u) => genQU ((Q2R k) * v)%R u
    | _ => !!
    end
  | _ => !!
  end.

(* Compute QUconv (genQU 2 'min) ('s).
Compute QUconv (genQU 2 'min) ($30*'s)%U.
Compute QUconv (genQU 2 'min) ('A). *)



(* Because (r1,c1,d1) + (c',d') = (r2,c2,d2), so:
1. r2 = r1 * c1 / c'
2. c' = c2
3. d1 = d' /\ d2 = d'
*)
Lemma QUconv_elim (q1 q2 : Quantity) (ref : Unit) :
  let '(mkNunit c' d') := u2n ref in
    (match QUcomps_opt q1, QUcomps_opt q2 with
    | Some (r1,c1,d1), Some (r2,c2,d2) => 
      (r1 * (Q2R c1) / (Q2R c') = r2) /\ (c' == c2)%Q /\ 
      (not (c2 == 0)%Q) /\ d1 = d' /\ d2 = d'
    | _, _ => False
    end)
     -> QUconv q1 ref == q2.
Proof.
  destruct q1 as [r1 (c1,d1)|] eqn:E1;
  destruct q2 as [r2 (c2,d2)|] eqn:E2; 
  destruct (u2n ref) as (c',d') eqn:E3; try easy. simpl.
  intros [H1 [H2 [H3 [H4 H5]]]]. subst.
  unfold Uconv. destruct d'.
  destruct (u2n (Ucons (Ucons (Ucons (Ucons (Ucons (Ucons (Ucons (Ucons # 
    (Qred c1) &T D1) &L D2) &M D3) &I D4) &O D5) &N D6) &J D7) &A D8)) 
    as (c3,d3) eqn:E4.
  rewrite E3.
  destruct (Deqb d3 {| D1 := D1; D2 := D2; D3 := D3; D4 := D4; D5 := D5; 
    D6 := D6; D7 := D7; D8:= D8 |}) eqn:E5.
  - unfold genQU. rewrite E3. apply QUeq_QUmake_bij. split; auto.
    + assert (c1 == c3)%Q.
      * apply Ugetcoef_u2n_eq in E4. rewrite ?Ugetcoef_Ucons in E4. 
        simpl in E4. apply Qred_complete in E4. rewrite Qred_Qred in E4.
        apply Qred_eq_iff in E4. auto.
      * rewrite H. rewrite Qreals.Q2R_div.
        { field. rewrite <- H2 in H3. intro. 
          replace 0 with (Q2R 0) in H0.
          { apply Qreals.eqR_Qeq in H0. easy. }
          compute. field. }
        rewrite <- H2 in H3. auto.
    + apply Neq_iff_each_eq. simpl. split; auto.
  - destruct d3. apply Deqb_false_iff_Dneq in E5. destruct E5.
    apply Ugetdim_u2n_eq in E4. rewrite ?Ugetdim_Ucons in E4; simpl in E4.
    do 7 destruct E4 as [? E4].
    rewrite ?Z.add_0_r in *. subst. auto.
Qed.



(** ** Automatic convert the unit of two quantities to best choice *)

(** *** Why do this?  2 'min + 10 's = 130 's *)

(*
given (q1,q2), generate (q1',q2')
1. check that q1 and q2 has same dims
2. choose which one?
  1 's + 1000 'ms -> 2 's is better
  1 's + 500 'ms -> 1500 'ms is better,
  because Coq has poor ability to calculate right now, so we don't want to 
  consider the magnitude part.
  On the other hand, any output is right, and it will produce just the right 
  result whenever you need any units.
  So, we choose which one? I dont't sure, 
    if their units are equal, then keep it the way it was,
    if their units are convertible, then choose first one units,
    if their units are not convertible, then return !!
*)
Definition QUautoconv (q1 q2 : Quantity) : (Quantity * Quantity) :=
  match q1, q2 with
  | QUmake v1 n1, QUmake v2 n2 =>
    if Neqb n1 n2 
    then (q1,q2)
    else
      let '(mkNunit c1 d1) := n1 in
        (q1, QUconv q2 (n2u n1))
  | _, _ => (!!, !!)
  end.

(* Eval compute in (QUautoconv (genQU 2 'min) (genQU 1 's)).
Eval compute in (QUautoconv (genQU 2 'rad) (genQU 1 'Hz)).
 *)
